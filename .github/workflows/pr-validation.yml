name: PR Validation for DMZ Branch

on:
  pull_request:
    branches: [dmz]

env:
  NODE_VERSION: "22.11.0"

jobs:
  pr-validation:
    name: Validate Pull Request
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      issues: write

    steps:
      - name: Checkout PR
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Fetch all branches
        run: |
          git fetch origin main
          git fetch origin dmz

      - name: Check if PR is based on latest main
        id: base-check
        run: |
          echo "Checking if PR branch is up-to-date with main..."

          # Get the merge base between PR branch and main
          MERGE_BASE=$(git merge-base HEAD origin/main)
          MAIN_HEAD=$(git rev-parse origin/main)

          echo "Merge base: $MERGE_BASE"
          echo "Main HEAD:  $MAIN_HEAD"

          if [ "$MERGE_BASE" != "$MAIN_HEAD" ]; then
            echo "‚ùå ERROR: This PR branch is not based on the latest main branch."
            echo ""
            echo "Your branch was created from an outdated version of main."
            echo "This will cause duplicate commits to appear in your PR."
            echo ""
            echo "To fix this, rebase your branch onto the latest main:"
            echo ""
            echo "  git fetch origin main"
            echo "  git rebase origin/main"
            echo "  git push --force-with-lease"
            echo ""
            echo "base-check-passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "‚úÖ PR branch is based on the latest main branch"
          echo "base-check-passed=true" >> $GITHUB_OUTPUT

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Detect changed starters
        id: detect-changes
        run: |
          echo "Detecting changed starter applications..."

          # For pull_request events, use PR base and head SHAs (not the merge commit)
          BASE_SHA="${{ github.event.pull_request.base.sha }}"
          HEAD_SHA="${{ github.event.pull_request.head.sha }}"

          echo "Base SHA: $BASE_SHA"
          echo "Head SHA: $HEAD_SHA"

          # Get list of changed files between PR base and PR head
          CHANGED_FILES=$(git diff --name-only "$BASE_SHA" "$HEAD_SHA")
          echo "Changed files:"
          echo "$CHANGED_FILES"

          # Detect which starters have changes
          CHANGED_STARTERS=""

          if echo "$CHANGED_FILES" | grep -q "^examples/kit-nextjs-skate-park/"; then
            CHANGED_STARTERS="$CHANGED_STARTERS kit-nextjs-skate-park"
          fi

          if echo "$CHANGED_FILES" | grep -q "^examples/kit-nextjs-article-starter/"; then
            CHANGED_STARTERS="$CHANGED_STARTERS kit-nextjs-article-starter"
          fi

          if echo "$CHANGED_FILES" | grep -q "^examples/kit-nextjs-location-finder/"; then
            CHANGED_STARTERS="$CHANGED_STARTERS kit-nextjs-location-finder"
          fi

          if echo "$CHANGED_FILES" | grep -q "^examples/kit-nextjs-product-listing/"; then
            CHANGED_STARTERS="$CHANGED_STARTERS kit-nextjs-product-listing"
          fi

          # If no specific starter changes detected, check for global changes
          if [ -z "$CHANGED_STARTERS" ]; then
            if echo "$CHANGED_FILES" | grep -q "^xmcloud.build.json\|^\.github/\|^README.md\|^CONTRIBUTING.md"; then
              echo "Global changes detected, validating all starters"
              CHANGED_STARTERS="kit-nextjs-skate-park kit-nextjs-article-starter kit-nextjs-location-finder kit-nextjs-product-listing"
            fi
          fi

          echo "Changed starters: $CHANGED_STARTERS"
          echo "changed-starters=$CHANGED_STARTERS" >> $GITHUB_OUTPUT

      - name: Install dependencies for changed starters
        run: |
          echo "Installing dependencies for changed starters..."

          for starter in ${{ steps.detect-changes.outputs.changed-starters }}; do
            if [ -d "examples/$starter" ]; then
              echo "Installing dependencies for $starter..."
              cd "examples/$starter"
              npm install
              cd ../..
            fi
          done

      - name: Generate Sitecore files for changed starters
        run: |
          echo "Generating Sitecore configuration files..."

          for starter in ${{ steps.detect-changes.outputs.changed-starters }}; do
            if [ -d "examples/$starter" ]; then
              echo "Generating files for $starter..."
              cd "examples/$starter"
              
              # Ensure .sitecore directory exists
              mkdir -p .sitecore
              
              # Try to generate files with Sitecore tools, fallback to minimal files if credentials are missing
              if npm run sitecore-tools:generate-map 2>/dev/null; then
                echo "‚úÖ Sitecore files generated successfully for $starter"
              else
                echo "‚ö†Ô∏è Sitecore tools failed (likely missing credentials), creating minimal files for $starter"
                
                # Create minimal sites.json
                echo '[{"name":"basic","hostName":"*","language":"en"}]' > .sitecore/sites.json
                
                # Create minimal metadata.json
                echo '{"packages":{"@sitecore-content-sdk/core":"1.1.0","@sitecore-content-sdk/nextjs":"1.1.0"}}' > .sitecore/metadata.json
                
                # Create minimal component-map.ts
                echo 'export default new Map();' > .sitecore/component-map.ts
                
                # Create minimal import-map.ts
                echo 'export default [];' > .sitecore/import-map.ts
              fi
              
              # Always ensure required files exist (they may not be generated by tools)
              if [ ! -f ".sitecore/sites.json" ]; then
                echo '[{"name":"basic","hostName":"*","language":"en"}]' > .sitecore/sites.json
              fi
              
              if [ ! -f ".sitecore/metadata.json" ]; then
                echo '{"packages":{"@sitecore-content-sdk/core":"1.1.0","@sitecore-content-sdk/nextjs":"1.1.0"}}' > .sitecore/metadata.json
              fi
              
              if [ ! -f ".sitecore/import-map.server.ts" ]; then
                echo 'export default [] as any;' > .sitecore/import-map.server.ts
              fi
              
              if [ ! -f ".sitecore/import-map.client.ts" ]; then
                echo 'export default [] as any;' > .sitecore/import-map.client.ts
              fi
              
              # Verify files were created
              echo "Created Sitecore files:"
              ls -la .sitecore/ || echo "Warning: .sitecore directory listing failed"
              
              cd ../..
            fi
          done

      - name: Lint and format check
        run: |
          set -e  # Exit immediately if any command fails
          echo "Running linting and formatting checks..."
          for starter in ${{ steps.detect-changes.outputs.changed-starters }}; do
            if [ -d "examples/$starter" ]; then
              echo "=================================="
              echo "Checking examples/$starter"
              echo "=================================="
              cd "examples/$starter"
              
              # Run linting
              echo "Running lint for $starter..."
              if ! npm run lint; then
                echo "‚ùå Linting failed for $starter"
                echo "::error::Linting failed for $starter"
                exit 1
              fi
              echo "‚úÖ Linting passed for $starter"
              
              # Check formatting (only if format:check script exists)
              # Warning only - does not fail the workflow
              if grep -q '"format:check"' package.json 2>/dev/null; then
                echo "Running format check for $starter..."
                if ! npm run format:check; then
                  echo "‚ö†Ô∏è WARNING: Formatting issues found in $starter"
                  echo "Run 'npm run prettier --write' to fix formatting issues"
                  echo "::warning::Formatting check found issues in $starter (non-blocking)"
                  # Continue without failing - format check is a warning only
                else
                  echo "‚úÖ Formatting check passed for $starter"
                fi
              else
                echo "‚è≠Ô∏è Skipping format check (no format:check script found in package.json)"
              fi
              
              cd ../..
            fi
          done

      - name: Type checking
        run: |
          echo "Running TypeScript type checking..."

          for starter in ${{ steps.detect-changes.outputs.changed-starters }}; do
            if [ -d "examples/$starter" ]; then
              echo "Type checking $starter..."
              cd "examples/$starter"
              
              # Check if type-check script exists
              if grep -q '"type-check"' package.json 2>/dev/null; then
                # Sitecore files already generated in previous step
                if npm run type-check; then
                  echo "‚úÖ Type checking passed for $starter"
                else
                  echo "‚ùå Type checking failed for $starter"
                  echo "::error::Type checking failed for $starter"
                  exit 1
                fi
              else
                echo "‚è≠Ô∏è Skipping type check (no type-check script found in package.json)"
              fi
              
              cd ../..
            fi
          done

      - name: Build changed starters
        env:
          # Sitecore Edge API Configuration
          SITECORE_EDGE_URL: ${{ secrets.SITECORE_EDGE_URL }}
          SITECORE_EDGE_CONTEXT_ID: ${{ secrets.SITECORE_EDGE_CONTEXT_ID }}
          NEXT_PUBLIC_SITECORE_EDGE_CONTEXT_ID: ${{ secrets.NEXT_PUBLIC_SITECORE_EDGE_CONTEXT_ID }}

          # Sitecore Configuration
          NEXT_PUBLIC_DEFAULT_SITE_NAME: ${{ vars.NEXT_PUBLIC_DEFAULT_SITE_NAME || 'basic' }}
          SITECORE_EDITING_SECRET: ${{ secrets.SITECORE_EDITING_SECRET }}

          # Additional Sitecore Environment Variables
          NEXT_PUBLIC_SITECORE_EDGE_URL: ${{ secrets.SITECORE_EDGE_URL }}
          NEXT_PUBLIC_SITECORE_API_KEY: ${{ secrets.NEXT_PUBLIC_SITECORE_API_KEY }}
          NEXT_PUBLIC_SITECORE_API_HOST: ${{ secrets.NEXT_PUBLIC_SITECORE_API_HOST }}
          NEXT_PUBLIC_DEFAULT_LANGUAGE: ${{ vars.NEXT_PUBLIC_DEFAULT_LANGUAGE || 'en' }}
          NEXT_PUBLIC_PERSONALIZE_SCOPE: ${{ vars.NEXT_PUBLIC_PERSONALIZE_SCOPE }}
          PERSONALIZE_MIDDLEWARE_EDGE_TIMEOUT: ${{ vars.PERSONALIZE_MIDDLEWARE_EDGE_TIMEOUT || '1000' }}
        run: |
          echo "Building changed starters..."
          echo "Sitecore Environment Variables:"
          echo "  SITECORE_EDGE_URL: ${SITECORE_EDGE_URL:+[SET]}"
          echo "  SITECORE_EDGE_CONTEXT_ID: ${SITECORE_EDGE_CONTEXT_ID:+[SET]}"
          echo "  NEXT_PUBLIC_SITECORE_EDGE_CONTEXT_ID: ${NEXT_PUBLIC_SITECORE_EDGE_CONTEXT_ID:+[SET]}"
          echo "  NEXT_PUBLIC_DEFAULT_SITE_NAME: ${NEXT_PUBLIC_DEFAULT_SITE_NAME}"
          echo "  SITECORE_EDITING_SECRET: ${SITECORE_EDITING_SECRET:+[SET]}"

          for starter in ${{ steps.detect-changes.outputs.changed-starters }}; do
            if [ -d "examples/$starter" ]; then
              echo "Building $starter..."
              cd "examples/$starter"
              
              if npm run build; then
                echo "‚úÖ Build successful for $starter"
              else
                echo "‚ùå Build failed for $starter"
                exit 1
              fi
              
              cd ../..
            fi
          done

      - name: Run tests for changed starters
        run: |
          echo "Running tests for changed starters..."

          for starter in ${{ steps.detect-changes.outputs.changed-starters }}; do
            if [ -d "examples/$starter" ]; then
              echo "Testing $starter..."
              cd "examples/$starter"
              
              # Check if test script exists
              if grep -q '"test"' package.json; then
                if npm test; then
                  echo "‚úÖ Tests passed for $starter"
                else
                  echo "‚ùå Tests failed for $starter"
                  exit 1
                fi
              else
                echo "‚è≠Ô∏è Skipping tests (no test script found in package.json)"
              fi
              
              cd ../..
            fi
          done

      - name: Comment PR with results
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
              });

              const botComment = comments.find(comment => 
                comment.user.type === 'Bot' && 
                comment.body.includes('## üîç PR Validation Results')
              );

              const status = '${{ job.status }}' === 'success' ? '‚úÖ **PASSED**' : '‚ùå **FAILED**';
              const emoji = '${{ job.status }}' === 'success' ? '‚úÖ' : '‚ùå';

              const body = `## üîç PR Validation Results

              ${emoji} **Status:** ${status}

              **Base Branch Check:** ${'${{ steps.base-check.outputs.base-check-passed }}' === 'true' ? '‚úÖ Based on latest main' : '‚ùå Not based on latest main - rebase required'}

              **Validated Starters:** ${{ steps.detect-changes.outputs.changed-starters }}

              **Checks Performed:**
              - ‚úÖ Linting and formatting
              - ‚úÖ TypeScript type checking
              - ‚úÖ Build verification
              - ‚úÖ Test execution

              **Next Steps:**
              ${'${{ job.status }}' === 'success' ? 
                '- ‚úÖ PR is ready for review and merge to dmz branch\n- After merge, the DMZ validation workflow will run as final gate\n- If DMZ validation passes, dmz can be manually merged to main using a merge commit' : 
                '- ‚ùå Please fix the issues above before merging\n- If not based on latest main: `git fetch origin main && git rebase origin/main && git push --force-with-lease`\n- If formatting issues: Run `npm run prettier`\n- Check the build logs for specific errors'
              }

              ---
              *This comment will be updated on each validation run*`;

              if (botComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id,
                  body: body
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: body
                });
              }
            } catch (error) {
              // Handle permission errors gracefully (e.g., PRs from forks)
              if (error.status === 403 || error.status === 404) {
                console.log('‚ö†Ô∏è Unable to comment on PR (may be from a fork or insufficient permissions). Validation results are still available in the workflow logs.');
                console.log('Validation Status:', '${{ job.status }}');
              } else {
                throw error;
              }
            }
